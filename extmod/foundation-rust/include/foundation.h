/*
 * SPDX-FileCopyrightText: Â© 2023 Foundation Devices, Inc. <hello@foundationdevices.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

#ifndef FOUNDATION_H
#define FOUNDATION_H

/*
 * Warning: This file is auto-generated by cbindgen, do not edit.
 *
 * Read the Justfile in order to re-generate this file.
 */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Maximum size of an encoded Uniform Resource.
 *
 * This value assumes a QR code of version of 16 with ECC L using
 * alphanumeric characters.
 */
#define UR_DECODER_MAX_STRING 1408

/**
 * Maximum sequence count for the decoder.
 *
 * Must be a power of two.
 */
#define UR_DECODER_MAX_SEQUENCE_COUNT 128

/**
 * Maximum message length that can be decoded.
 */
#define UR_DECODER_MAX_MESSAGE_LEN (24 * 1024)

/**
 * Maximum number of mixed parts that can be held.
 */
#define UR_DECODER_MAX_MIXED_PARTS 8

/**
 * Size of the decoder queue.
 */
#define UR_DECODER_QUEUE_SIZE 8

/**
 * Maximum size of an encoded Uniform Resource.
 *
 * This value assumes a QR code of version of 12 with ECC L using
 * alphanumeric characters.
 */
#define UR_ENCODER_MAX_STRING 535

/**
 * Minimum size of an encoded Uniform Resource.
 *
 * This value assumes a QR code of version of 7 with ECC L using
 * alphanumeric characters.
 */
#define UR_ENCODER_MIN_STRING 224

/**
 * `mainnet` network.
 */
#define UR_NETWORK_MAINNET 0

/**
 * `testnet` network.
 */
#define UR_NETWORK_TESTNET 1

typedef enum {
  BTC,
} UR_CoinType;

typedef enum {
  UR_ERROR_KIND_OTHER,
  UR_ERROR_KIND_UNSUPPORTED,
  UR_ERROR_KIND_NOT_MULTI_PART,
} UR_ErrorKind;

/**
 * Passport model.
 */
typedef enum {
  /**
   * Founders Edition.
   */
  PASSPORT_MODEL_FOUNDERS_EDITION,
  /**
   * Batch 2.
   */
  PASSPORT_MODEL_BATCH2,
} UR_PassportModel;

/**
 * Uniform Resource decoder.
 */
typedef struct UR_Decoder UR_Decoder;

/**
 * Uniform Resource encoder.
 */
typedef struct UR_Encoder UR_Encoder;

typedef struct {
  UR_ErrorKind kind;
  const char *message;
  size_t len;
} UR_Error;

typedef struct {
  UR_CoinType coin_type;
  uint64_t network;
} UR_CryptoCoinInfo;

/**
 * Metadata for the complete or partial derivation path of a key.
 */
typedef struct {
  /**
   * The fingerprint of this key's direct ancestor.
   *
   * A value of `0` means that the fingerprint is not present.
   */
  uint32_t source_fingerprint;
  /**
   * How many derivations this key is from the master (which is 0).
   *
   * 0 if this is a public key derived directly from a master key.
   */
  uint8_t depth;
  /**
   * Whether `depth` is present.
   */
  bool has_depth;
} UR_CryptoKeypath;

/**
 * Derived `crypto-hdkey`.
 */
typedef struct {
  /**
   * `true` if this is a private key.
   */
  bool is_private;
  /**
   * The key material.
   */
  uint8_t key_data[33];
  /**
   * Chain code.
   */
  uint8_t chain_code[32];
  /**
   * Whether `chain_code` is present.
   */
  bool has_chain_code;
  /**
   * How the key should be used.
   */
  UR_CryptoCoinInfo use_info;
  /**
   * Whether `use_info` is present.
   */
  bool has_use_info;
  /**
   * How the key was derived.
   */
  UR_CryptoKeypath origin;
  /**
   * Whether `origin` is present.
   */
  bool has_origin;
  /**
   * The fingerprint of this key's direct ancestor.
   *
   * A value of `0` means that the fingerprint is not present.
   */
  uint32_t parent_fingerprint;
} UR_DerivedKey;

/**
 * A `crypto-hdkey`.
 */
typedef enum {
  DerivedKey,
} UR_HDKey_Tag;

typedef struct {
  UR_HDKey_Tag tag;
  union {
    struct {
      UR_DerivedKey derived_key;
    };
  };
} UR_HDKey;

/**
 * Supply chain validation challenge.
 */
typedef struct {
  /**
   * The ID challenge.
   */
  uint8_t id[32];
  /**
   * The signature.
   */
  uint8_t signature[64];
} UR_Challenge;

/**
 * Passport custom `crypto-request`.
 */
typedef struct {
  /**
   * Transaction ID.
   */
  uint8_t transaction_id[16];
  /**
   * Supply chain validation challenge.
   */
  UR_Challenge scv_challenge;
  /**
   * Whether SCV challenge is available.
   */
  bool has_scv_challenge;
  /**
   * Request Passport model.
   */
  bool passport_model;
  /**
   * Request Passport firmware version.
   */
  bool passport_firmware_version;
} UR_PassportRequest;

/**
 * Supply Chain Validation solution.
 */
typedef struct {
  const char *word1;
  size_t word1_len;
  const char *word2;
  size_t word2_len;
  const char *word3;
  size_t word3_len;
  const char *word4;
  size_t word4_len;
} UR_Solution;

/**
 * Passport custom `crypto-request`.
 */
typedef struct {
  /**
   * Transaction ID.
   */
  uint8_t transaction_id[16];
  /**
   * Supply chain validation challenge.
   */
  UR_Solution scv_solution;
  /**
   * Whether `scv_solution` is present.
   */
  bool has_scv_solution;
  /**
   * Passport model.
   */
  UR_PassportModel passport_model;
  /**
   * Whether `passport_model` present.
   */
  bool has_passport_model;
  /**
   * Passport firmware version.
   */
  const char *passport_firmware_version;
  /**
   * Passport firmware version length.
   */
  size_t passport_firmware_version_len;
  /**
   * Whether `passport_model` present.
   */
  bool has_passport_firmware_version;
} UR_PassportResponse;

/**
 * A uniform resource.
 */
typedef enum {
  /**
   * `bytes`.
   */
  Bytes,
  /**
   * `crypto-hdkey`.
   */
  CryptoHDKey,
  /**
   * `crypto-psbt`.
   */
  CryptoPSBT,
  /**
   * Passport custom `crypto-request`.
   */
  PassportRequest,
  /**
   * Passport custom `crypto-response`.
   */
  PassportResponse,
} UR_Value_Tag;

typedef struct {
  const uint8_t *data;
  size_t len;
} Bytes_Body;

typedef struct {
  const uint8_t *data;
  size_t len;
} CryptoPSBT_Body;

typedef struct {
  UR_Value_Tag tag;
  union {
    Bytes_Body bytes;
    struct {
      UR_HDKey crypto_hd_key;
    };
    CryptoPSBT_Body crypto_psbt;
    struct {
      UR_PassportRequest passport_request;
    };
    struct {
      UR_PassportResponse passport_response;
    };
  };
} UR_Value;







#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern UR_Decoder UR_DECODER;

extern UR_Encoder UR_ENCODER;

/**
 * Computes a Schnorr signature over the message `data`.
 *
 * - `data` is the message hash.
 * - `secret_key` is the secret key used to sign the message.
 * - `signature` is the output of the resulting signature.
 */
void foundation_secp256k1_sign_schnorr(const uint8_t (*data)[32],
                                       const uint8_t (*secret_key)[32],
                                       uint8_t (*signature)[64]);

/**
 * Receive a Uniform Resource part.
 *
 * # Safety
 *
 * - `ur` must point to valid memory and must have a length of `ur_len` bytes.
 */
bool ur_decoder_receive(UR_Decoder *decoder,
                        const uint8_t *ur,
                        size_t ur_len,
                        UR_Error *error,
                        uint32_t *num_frames);

/**
 * Returns `true` if the decoder is complete and no more data is needed.
 */
bool ur_decoder_is_complete(UR_Decoder *decoder);

/**
 * Returns the calculated estimated percentage of completion.
 */
uint32_t ur_decoder_estimated_percent_complete(UR_Decoder *decoder);

/**
 * Clear the decoder in order so a new message can be received.
 */
void ur_decoder_clear(UR_Decoder *decoder);

/**
 * Returns `true` if the decoder doesn't contain any data.
 */
bool ur_decoder_is_empty(UR_Decoder *decoder);

/**
 * Decode the message as an UR value.
 */
bool ur_decoder_decode_message(UR_Decoder *decoder,
                               UR_Value *value,
                               UR_Error *error);

/**
 * Returns `true` if the string is a uniform resource, `false` otherwise.
 *
 * # Safety
 *
 * - `ur` must point to valid memory and must have a length of `ur_len` bytes.
 */
bool ur_validate(const uint8_t *ur, size_t ur_len);

/**
 * # Safety
 *
 * Same as in `ur_decoder_decode_message`
 */
bool ur_decode_single_part(const uint8_t *ur,
                           size_t ur_len,
                           UR_Value *value,
                           UR_Error *error);

/**
 * Start the encoder.
 *
 * # Parameters
 *
 * - `value` is the uniform resource to encode.
 * - `max_chars` is the maximum fragment length in bytes.
 *
 * # Safety
 *
 * If the `UR_Value` is of type `Bytes` then the pointer must be a valid value
 * and its length too.
 *
 * This function assumes that is called on the same thread and its not used
 * concurrently.
 */
void ur_encoder_start(UR_Encoder *encoder,
                      const UR_Value *value,
                      size_t max_chars);

/**
 * Returns the UR corresponding to the next fountain encoded part.
 *
 * # Safety
 *
 * This function must not be called if `ur_encoder_start` was not called to
 * start the encoder. Or if the data used to start the encoder is freed.
 *
 * # Return Value
 *
 * The return value is a NULL terminated string encoded using an uppercase
 * alphabet and using only the characters allowed in QR code alphanumeric
 * mode.
 *
 * The pointer is valid until `ur_encoder_next_part` or `ur_encoder_start`
 * are called.
 */
void ur_encoder_next_part(UR_Encoder *encoder, const char **ur, size_t *ur_len);

/**
 * Passport custom `crypto-response`.
 * Create a new `bytes` UR.
 */
void ur_registry_new_bytes(UR_Value *value, uint8_t *data, size_t len);

/**
 * Create a new derived `crypto-hdkey` UR.
 */
void ur_registry_new_derived_key(UR_Value *value,
                                 bool is_private,
                                 const uint8_t (*key_data)[33],
                                 const uint8_t (*chain_code)[32],
                                 const UR_CryptoCoinInfo *use_info,
                                 const UR_CryptoKeypath *origin,
                                 uint32_t parent_fingerprint);

/**
 * Create a new `crypto-psbt` UR.
 */
void ur_registry_new_crypto_psbt(UR_Value *value, uint8_t *data, size_t len);

/**
 * Create a new Passport ustom `crypto-response` UR.
 */
void ur_registry_new_passport_response(UR_Value *value,
                                       const uint8_t (*transaction_id)[16],
                                       const UR_Solution *solution,
                                       UR_PassportModel passport_model,
                                       const char *passport_firmware_version,
                                       size_t passport_firmware_version_len);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* FOUNDATION_H */
